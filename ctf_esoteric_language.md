***Brainfuck***

🧠 What is Brainfuck?
Brainfuck is an esoteric programming language that operates on a simple machine model with:

an array of memory cells (usually 30,000), all initialized to zero

a data pointer that moves left/right

only 8 commands:

Command	Description
>	Move pointer to the right
<	Move pointer to the left
+	Increment the byte at the pointer
-	Decrement the byte at the pointer
.	Output the byte at the pointer
,	Input a byte and store it
[	Jump past the matching ] if the byte at the pointer is zero
]	Jump back to the matching [ if the byte is nonzero


You can run Brainfuck code in these online interpreters:

https://copy.sh/brainfuck/

https://tio.run/#brainfuck

https://www.dcode.fr/brainfuck-language

https://md5decrypt.net/en/Brainfuck-translator/

https://www.cachesleuth.com/bfook.html



***Malbolge***

Malbolge is an esoteric programming language known for its extreme difficulty and obscure design. It was created in 1998 by Ben Olmstead with the intention of being almost impossible to program in.

Key facts about Malbolge:
Turing complete but very hard to write any meaningful program by hand.

Uses crazy encryption-like instructions that self-modify as the program runs.

Memory and instruction manipulation are based on ternary (base-3) and weird arithmetic.

The language's complexity stems from instructions that change when executed.

The first “Hello, World!” program in Malbolge was not written by a human but generated by a computer search.

Basic concepts:
Program memory size: 59049 (3^10) locations.

Instructions are encrypted using a crazy "crazy operation" which permutes opcode values.

Execution uses ternary digits (trits) and modular arithmetic.

The language has only 8 instructions, represented by characters in a scrambled mapping.

Programs usually look like nonsensical gibberish strings.

The eight instructions in Malbolge:
Mnemonic	Effect	Character codes (encrypted)
j	Jump	'j'
i	Input	'i'
o	Output	'o'
p	Rotate data	'p'
d	Decrement memory cell	'd'
c	Compare and skip	'c'
*	Crazy operation (modify)	'*'
m	Move data pointer	'm'

Note: These are conceptual mnemonics — in practice, you never see these clean names; the code uses characters that map to instructions after decoding.

Example: "Hello World!" in Malbolge

(=<`#9]~6ZY32Vx/4Rs+0Po-&JkDh"F}B@;w^A|?}{[zyxwvu
(It's basically unintelligible.)


What to expect in a CTF Malbolge challenge?
Given a Malbolge program (obfuscated nonsense), find the flag it outputs.

Write a Malbolge program that outputs a flag string.

Analyze a corrupted or partial Malbolge program and repair it.

**Interpreter**: https://malbolge.doleczek.pl/ 


***PIET***

Piet in CTFs — Common challenge types
Given a Piet program image, run it to find the flag output.
You often get an image file that, when interpreted as Piet code, prints a flag string.

Given a Piet program, analyze or reverse-engineer it to understand what it outputs.
Sometimes you must step through its logic, colors, and flow manually.

Create or modify a Piet program to produce a desired output, e.g., a flag.
This is rarer but sometimes part of advanced challenges.

Combine with steganography or hidden image techniques.
Flags can be hidden by subtle color changes or overlay images.

How to approach Piet challenges in CTFs
**Use an interpreter**: The easiest way is to run the image through a Piet interpreter to see what it outputs.
Examples:

---npiet (popular CLI interpreter)

---Online Piet interpreter (web-based)

---Piet online interpreter on esolangs.org

**Understand the color model**: Piet programs use a 20-color palette (6 hues × 3 lightness levels + black and white).
The instruction executed depends on hue and brightness changes between adjacent color blocks.

**Analyze flow direction**: The “pointer” moves through color blocks, turning based on blocked paths.

**Look for output commands**: Piet supports outputting characters or numbers — look for the outputs in program flow.

**Tools & resources for Piet CTF challenges**
Online IDE and interpreter: Dangermouse Piet IDE

CLI tools: npiet interpreter (search GitHub for “npiet”)

Specification and explanation: Piet on esolangs.org

Color chart & command table: Helps understand how color changes map to instructions.





**OOK!**

What is Ook!?
Created by David Morgan-Mar (same person as Piet).

Designed as a joke language for orangutans, based on Brainfuck.

Uses only three tokens: “Ook.”, “Ook?”, and “Ook!”.

Every Brainfuck command is encoded as a pair of these tokens.

Programs look like a long series of “Ook. Ook! Ook? Ook.” etc.

Why is Ook! used in CTFs?
It’s basically Brainfuck disguised in a silly syntax.

Makes reverse-engineering harder if you don’t know the translation.

Good for puzzles where you get a long Ook! program and need to decode or run it.

Challenges often involve:

Decoding Ook! code to Brainfuck.

Running the code to extract a flag.

Writing minimal Ook! code for some task.

Basic mapping from Ook! to Brainfuck
Brainfuck command	Ook! equivalent (two tokens)
>	Ook. Ook?
<	Ook? Ook.
+	Ook. Ook.
-	Ook! Ook!
. (output)	Ook! Ook.
, (input)	Ook. Ook!
[	Ook! Ook?
]	Ook? Ook!

Decoder: https://www.dcode.fr/ook-language
         https://www.cachesleuth.com/bfook.html
         
         
HexaHue:

https://www.dcode.fr/hexahue-cipher
https://www.boxentriq.com/code-breaking/hexahue

